
    스프링 시큐리티 - 아키텍쳐

        SecurityContextHold, Authentication

        Principal - 사용자 정보
        Principal 정보를 Authentication 객체 안에 담아 관리

        Authentication -> SecurityContext -> SecurityContextHolder 이러한 순서로 감싸서 사용


        Authentication
            Principal과 GrantAuthority 제공.
        Principal
            사용자 정보
            Principal 정보를 Authentication 객체 안에 담아 관리
            UserDetailsService에서 리턴한 그 객체.
            객체는 UserDetails 타입.

        SecurityContext 기본적으로 ThreadLocal을 사용한다
            ThreadLocal - 한 쓰레드 내에서 공유하는 저장소
        GrantAuthority:
            “ROLE_USER”, “ROLE_ADMIN”등 Principal이 가지고 있는 “권한”을 나타낸다.
            인증 이후, 인가 및 권한 확인할 때 이 정보를 참조한다.

        User
            유저 정보 객체
        UserDetails
            애플리케이션이 가지고 있는 유저 정보와 스프링 시큐리티가 사용하는 Authentication 객체 사이의 어댑터.
        UserDetailsService
            유저 정보를 UserDetails 타입으로 가져오는 DAO (Data Access Object) 인터페이스.

        서블릿 기반 : 어떤 요청이 하나 들어왔을 때 그 요청이 처리되는 쓰레드는 async한 기능을 사용하지 않는 이상 동일한 쓰레드가 그 요청을 처리한다
        서블릿 컨테이너 기본전략 request per thread


         AuthenticationManager와 Authentication
             스프링 시큐리티에서 인증(Authentication)은 AuthenticationManager가 한다.
             SecurityContextHolder는 인증 정보를 담고 있는 곳
             ProviderManager 보통으로 사용한다
             AuthenticationProvider들을 사용해서 적절한 인증 방법으로 처리한다, 만약 없다면 Parent ProviderManager 사용

             Authentication
                 Principal: UserDetailsService에서 리턴한 그 객체 (User)
                 Credentials:
                 GrantedAuthorities

         Spring Security : Authentication Architecture
            https://springbootdev.com/2017/08/23/spring-security-authentication-architecture/

        ThreadLocal
            Java.lang 패키지에서 제공하는 쓰레드 범위 변수. 즉, 쓰레드 수준의 데이터 저장소.
            같은 쓰레드 내에서만 공유.
            따라서 같은 쓰레드라면 해당 데이터를 메소드 매개변수로 넘겨줄 필요 없음.
            SecurityContextHolder의 기본 전략.

        Authencation과 SecurityContextHolder
            크게 2가지 fileter가 authencation 객체를 SecurityContextHolder 넣어준다
            UsernamePasswordAuthenticationFilter
                요청마다 기존에 캐싱하고 있는 SecurityContext를 복구 하려고 한다
                요청이 끝나면 SecurityContext 비워준다
                폼 인증을 처리하는 시큐리티 필터
                인증된 Authentication 객체를 SecurityContextHolder에 넣어주는 필터
                SecurityContextHolder.getContext().setAuthentication(authentication)

            SecurityContextPersisenceFilter
                SecurityContext를 HTTP session에 캐시(기본 전략)하여 여러 요청에서 Authentication을 공유할 수 있 공유하는 필터.
                SecurityContextRepository를 교체하여 세션을 HTTP session이 아닌 다른 곳에 저장하는 것도 가능하다.

        스프링 시큐리티가 제공하는 필터들
            WebAsyncManagerIntergrationFilter
            SecurityContextPersistenceFilter
            HeaderWriterFilter
            CsrfFilter
            LogoutFilter
            UsernamePasswordAuthenticationFilter
            DefaultLoginPageGeneratingFilter
            DefaultLogoutPageGeneratingFilter
            BasicAuthenticationFilter
            RequestCacheAwareFtiler
            SecurityContextHolderAwareReqeustFilter
            AnonymouseAuthenticationFilter
            SessionManagementFilter
            ExeptionTranslationFilter
            FilterSecurityInterceptor

        이 모든 필터는 FilterChainProxy가 호출한다.
            getFilters - chain의 목록을 가져온다, SecurityFilterChain의 요청이 url패턴이 match되면 matching하는 필터 체인을 가져온다
            필터들을 순회하면서 실행
            FilterChainProxy가 필터 목록을 순차적으로 실행 시켜 준다
            Custom한 SecurityConfig가 SecurityFilterChain을 만드는데 사용된다

        DelegatingFilterProxy
            일반적인 서블릿 필터.
            서블릿 필터 처리를 스프링에 들어있는 빈으로 위임하고 싶을 때 사용하는 서블릿 필터.
            어떤 bean에서 위임할지 -> 타겟 빈 이름을 설정한다.
            스프링 부트 없이 스프링 시큐리티 설정할 때는 AbstractSecurityWebApplicationInitializer를 사용해서 등록.
            스프링 부트를 사용할 때는 자동으로 등록 된다. (SecurityFilterAutoConfiguration)

        FilterChainProxy
            보통 “springSecurityFilterChain” 이라는 이름의 빈으로 등록된다.


            서블릿 필터                                    시큐리티 필터 목록
               |                                               Filter
               |                                               Filter
            DelegatingFilterProxy -> FilterChainProxy ->       ...
               |
               |
            서블릿 필터

        AccessDecisionManager
            - 여러개의 voter를 가질 수 있음
                voter를 거치면서 유효한지 확인을 한다
            인가를 할때 사용
            AffirmativeBased: 여러 Voter중에 한명이라도 허용하면 허용. 기본 전략.
            ConsensusBased: 다수결
            UnanimousBased: 만장일치

            AccessDecisionVoter
                ACCESS_GRANTED (허용) 1, ACCESS_ABSTAIN 0 (모르겠음), ACCESS_DENIED -1 (거부)
                해당 Authentication이 특정한 Object에 접근할 때 필요한 ConfigAttributes를 만족하는지 확인한다.
                WebExpressionVoter: 웹 시큐리티에서 사용하는 기본 구현체, ROLE_Xxxx가 매치하는지 확인.
                RoleHierarchyVoter: 계층형 ROLE 지원. ADMIN > MANAGER > USER

        FilterSecurityInterceptor
            AccessDecisionManager를 사용하여 Access Control 또는 예외 처리 하는 필터.
            대부분의 경우 FilterChainProxy에 제일 마지막 필터로 들어있다.

        ExceptionTranslationFilter
            필터 체인에서 발생하는 AccessDeniedException과 AuthenticationException을 처리하는 필터

            AuthenticationException 발생 시
                AuthenticationEntryPoint 실행
                AbstractSecurityInterceptor 하위 클래스(예, FilterSecurityInterceptor)에서 발생하는 예외만 처리.

            AccessDeniedException 발생 시
                익명 사용자라면 AuthenticationEntryPoint 실행
                익명 사용자가 아니면 AccessDeniedHandler에게 위임

        Security 설정 파일 webSecurity 만든다, WebSecurity로 filter chain을 만든다

        파비콘의 경우 시큐리티 걸린다. 따라서 로그인 요청도 보낸다. 이러한 요청들로 서버리소스 낭비 따라서 static 리소스 요청은 ignore 할 수 있음

        WebAsyncManagerIntegrationFilter는 async handler 지원하는 기능, 일반적으로는 ThreadLocal 사용하지만 async 기능시 다른 쓰레드 사용하게 된다
        따라서 다른 쓰레드에도 동일한 Security Context를 사용할 수 있도록 지원해주는 필터

            PreProcess: SecurityContext를 설정한다.
            Callable: 비록 다른 쓰레드지만 그 안에서는 동일한 SecurityContext를 참조할 수 있다.
            PostProcess: SecurityContext를 정리(clean up)한다.

        SecurityContextPersistenceFilter
            SecurityContextRepository를 사용해서 기존의 SecurityContext를 읽어오거나 초기화 한다.
            기본으로 사용하는 전략은 HTTP Session을 사용한다.

    시큐리티 관련 헤더 추가하는 필터: HeaderWriterFilter (직접 설정 x)

        응답 헤더에 시큐리티 관련 헤더를 추가해주는 필터
            XContentTypeOptionsHeaderWriter: 마임 타입 스니핑 방어. // 브라우저들이 content 분석하고 실행 불가능한 마임 타입을 실행하려고 했을 때 발생
            XXssProtectionHeaderWriter: 브라우저에 내장된 XSS 필터 적용. // XSS 방어, 브라우저 XSS 기본 필터 사용
            CacheControlHeadersWriter: 캐시 히스토리 취약점 방어.
            HstsHeaderWriter: HTTPS로만 소통하도록 강제.
            XFrameOptionsHeaderWriter: clickjacking 방어.

        Cache-Control: no-cache, no-store, max-age=0, must-revalidate // Cache 사용하지 않도록 // 동적인 page는 민감한 정보를 노출할 수 있음 따라서 Cache정보 비운다
        Content-Language: en-US
        Content-Type: text/html;charset=UTF-8 // (1)일 경우 반드시 content type으로만 렌더링
        Date:
        Expires: 0
        Pragma: no-cache
        Transfer-Encoding: chunked
        X-Content-Type-Options: nosniff // (1)
        X-Frame-Options: DENY // (3) clickjacking 방어
        X-XSS-Protection: 1; mode=block // (2) 1이 XSS 기본 필터 방어

    CsrfFilter : Csrf 어택 방지 필터
        의도한 사용자만 리소스를 변경할 수 있도록 허용하는 필터, CSRF 토큰을 사용하여 방지.

        CSRF : 인증된 유저의 계정을 사용해 악의적인 변경 요청을 만들어 보내는 기법.

        CORS를 사용할 때 특히 주의 해야 함.
            타 도메인에서 보내오는 요청을 허용하기 때문에

        필터 - 리소스를 변경할만한 요청은 CSRF 토큰을 보낸다. CSRF 토큰 일치하는 지 확인한다

    LogoutFilter : 로그아웃 처리 필터
        CompositeLogoutHandler로 로그아웃 handler 들고 있음
        여러 LogoutHandler를 사용하여 로그아웃시 필요한 처리를 하며 이후에는 LogoutSuccessHandler를 사용하여 로그아웃 후처리를 한다.

        LogoutHandler
            CsrfLogoutHandler
            SecurityContextLogoutHandler

        LogoutSuccessHandler
            SimplUrlLogoutSuccessHandler

    UsernamePasswordAuthenticationFilter : 폼 인증 처리 필터
        폼 로그인을 처리하는 인증 필터
            사용자가 폼에 입력한 username과 password로 Authentcation(UsernamePasswordAuthenticationToken)을 만들고 AuthenticationManager를 사용하여 인증을 시도한다.
            AuthenticationManager (ProviderManager)는 여러 AuthenticationProvider를 사용하여 인증을 시도하는데, 그 중에 DaoAuthenticationProvider는 UserDetailsServivce를 사용하여 UserDetails 정보를 가져와 사용자가 입력한 password와 비교한다

    Default(Login/Logout)PageGeneratingFilter 로그인/로그아웃 폼 페이지 생성 필터
        파라미터 이름을 바꿀 수 있음(크게 의미 x)
        커스텀한 로그인 페이지를 따로 설정하여 커스터 마이징 가능( 이때는 필터 등록되지 않음) http.loginPage

    Basic 인증 처리 필터 : BasicAuthenticationFilter
        Basic 인증(stateless)
            요청 헤더에 username과 password를 실어 보내면 서버 or 브라우저가 그 값을 읽어 인증하는 방식
            Authorization: Basic (username:pssword) base64로 인코딩 한것
            브라우저 기반 요청이 클라이언트의 요청을 처리할 때 사용
            보안에 취약 반드시 https를 사용

    RequsetCacheAwareFilter : 요청 캐시 필터
        현재 요청과 관련 있는 캐시된 요청이 있는지 찾아서 적용하는 필터.
        session에 캐시한다
        적용되는 process : 예외가 발생해서 로그인 처리 page -> 사용자 로그인 -> (캐시된 요청) 원래 사용자가 가고 싶은 page 보여준다
            캐시된 요청이 없다면, 현재 요청 처리
            캐시된 요청이 있다면, 해당 캐시된 요청 처리

    SecurityContextHolderAwareRequestFilter : 시큐리티 관련 서블릿 스팩 구현 필터

        시큐리티 관련 서블릿 API를 구현해주는 필터(서블릿 API 지원)
            HttpServletRequest#authenticate(HttpServletResponse)
            HttpServletRequest#login(String, String)
            HttpServletRequest#logout()
            AsyncContext#start(Runnable)

    AnonymousAuthenticationFilter : 익명 인증 필터
        아무도 인증을 하지 않을 요청일때 익명 객체를 만들어 넣어준다
        null object pattern null을 대변하는 object를 만들어서 사용하는 pattern
        현재 SecurityContext에 Authentication이 null이면 “익명 Authentication”을 만들어 넣어주고, null이 아니면 아무일도 하지 않는다.

    SessionManagementFilter : 세션 관리 필터
        주요한 기능
            세션 변조 방지 전략 설정: sessionFixation
                세션 변조란 ? 공격자가 로그인을 통해 session 정보를 받아온다. 쿠키에 들어있는 session id를 공격 대상에게 보낸다.
                공격대상은 로그인을 하고 웹 서버 입장에서는 session id가 동일하므로 공격대상의 정보 탈취당한다
                spring security 서블릿 컨테이너 마다 약간 다름
                    migrateSession (서블릿 3.0- 컨테이너 사용시 기본값) 인증이되었을 때 새로운 session을 만들고 기존의 session 안의 일부 값을 복사해온다
                    changeSessionId (서브릿 3.1+ 컨테이너 사용시 기본값) session id만 바꿈

            유효하지 않은 세션을 리다이렉트 시킬 URL 설정
            동시성 제어: maximumSessions
            세션 생성 전략: sessionCreationPolicy
                IF_REQUIRED 필요하면 만든다(기본 값)
                NEVER  spring security에서 만들지는 않으나 기존에 session이 있는 경우 사용
                STATELESS 세션 쓰고 싶지 않을때
                ALWAYS

    ExceptionTranslationFilter : 인증/인가 예외 처리 필터
        ExceptionTranslationFilter -> FilterSecurityInterceptor (AccessDecisionManager, AffirmativeBased)
        밀접한 관계, ExceptionTranslationFilter가  FilterSecurityInterceptor 감싸고 실행

        AuthenticationException 인증 예외
            AuthenticationEntryPoint 인증 예외 처리 / 인증 가능한 page로 보낸다 / 인증이 없을 때

        AccessDeniedException 인가 예외
            AccessDeniedHandler 인가 예외 처리 / 403 error message 보낸다

    FilterSecurityInterceptor : 인가 처리 필터
        HTTP 리소스 시큐리티 처리를 담당하는 필터. AccessDecisionManager를 사용하여 인가를 처리한다.

    RememberMeAuthenticationFilter
        세션이 사라지거나 만료가 되더라도 쿠키 또는 DB를 사용하여 저장된 토큰 기반으로 인증을 지원하는 필터

    Extra

    메소드 security

        웹에서 뿐만이 아니라 다른 곳에서도 spring security 사용 가능
        https://www.baeldung.com/spring-security-method-security
        @Secured와 @RollAllowed
        메소드 호출 이전에 권한을 확인한다.
        스프링 EL을 사용하지 못한다.

        @PreAuthorize와 @PostAuthorize
        메소드 호출 이전 @있다.

    스프링 데이터 연동


    * spring handler argument
        HandlerMethodArgumentResolver
        https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments